{"ast":null,"code":"import React, { PureComponent } from 'react';\nimport { classNames } from '../../utilities/css.js';\nimport { getRectForNode, Rect } from '../../utilities/geometry.js';\nimport { dataPolarisTopBar, layer } from '../shared.js';\nimport { windowRect, calculateVerticalPosition, calculateHorizontalPosition, rectIsOutsideOfRect, intersectionWithViewport } from './utilities/math.js';\nimport styles from './PositionedOverlay.scss.js';\nimport { Scrollable } from '../Scrollable/Scrollable.js';\nimport { EventListener } from '../EventListener/EventListener.js';\nconst OBSERVER_CONFIG = {\n  childList: true,\n  subtree: true,\n  characterData: true\n};\n\nclass PositionedOverlay extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      measuring: true,\n      activatorRect: getRectForNode(this.props.activator),\n      right: undefined,\n      left: undefined,\n      top: 0,\n      height: 0,\n      width: null,\n      positioning: 'below',\n      zIndex: null,\n      outsideScrollableContainer: false,\n      lockPosition: false\n    };\n    this.overlay = null;\n    this.scrollableContainer = null;\n    this.observer = void 0;\n\n    this.overlayDetails = () => {\n      const {\n        measuring,\n        left,\n        right,\n        positioning,\n        height,\n        activatorRect\n      } = this.state;\n      return {\n        measuring,\n        left,\n        right,\n        desiredHeight: height,\n        positioning,\n        activatorRect\n      };\n    };\n\n    this.setOverlay = node => {\n      this.overlay = node;\n    };\n\n    this.handleMeasurement = () => {\n      const {\n        lockPosition,\n        top\n      } = this.state;\n      this.observer.disconnect();\n      this.setState(_ref => {\n        let {\n          left,\n          top,\n          right\n        } = _ref;\n        return {\n          left,\n          right,\n          top,\n          height: 0,\n          positioning: 'below',\n          measuring: true\n        };\n      }, () => {\n        if (this.overlay == null || this.scrollableContainer == null) {\n          return;\n        }\n\n        const {\n          activator,\n          preferredPosition = 'below',\n          preferredAlignment = 'center',\n          onScrollOut,\n          fullWidth,\n          fixed,\n          preferInputActivator = true\n        } = this.props;\n        const preferredActivator = preferInputActivator ? activator.querySelector('input') || activator : activator;\n        const activatorRect = getRectForNode(preferredActivator);\n        const currentOverlayRect = getRectForNode(this.overlay);\n        const scrollableElement = isDocument(this.scrollableContainer) ? document.body : this.scrollableContainer;\n        const scrollableContainerRect = getRectForNode(scrollableElement);\n        const overlayRect = fullWidth ? new Rect({ ...currentOverlayRect,\n          width: activatorRect.width\n        }) : currentOverlayRect; // If `body` is 100% height, it still acts as though it were not constrained to that size. This adjusts for that.\n\n        if (scrollableElement === document.body) {\n          scrollableContainerRect.height = document.body.scrollHeight;\n        }\n\n        let topBarOffset = 0;\n        const topBarElement = scrollableElement.querySelector(`${dataPolarisTopBar.selector}`);\n\n        if (topBarElement) {\n          topBarOffset = topBarElement.clientHeight;\n        }\n\n        const overlayMargins = this.overlay.firstElementChild && this.overlay.firstChild instanceof HTMLElement ? getMarginsForNode(this.overlay.firstElementChild) : {\n          activator: 0,\n          container: 0,\n          horizontal: 0\n        };\n        const containerRect = windowRect();\n        const zIndexForLayer = getZIndexForLayerFromNode(activator);\n        const zIndex = zIndexForLayer == null ? zIndexForLayer : zIndexForLayer + 1;\n        const verticalPosition = calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed, topBarOffset);\n        const horizontalPosition = calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment);\n        this.setState({\n          measuring: false,\n          activatorRect: getRectForNode(activator),\n          left: preferredAlignment !== 'right' ? horizontalPosition : undefined,\n          right: preferredAlignment === 'right' ? horizontalPosition : undefined,\n          top: lockPosition ? top : verticalPosition.top,\n          lockPosition: Boolean(fixed),\n          height: verticalPosition.height || 0,\n          width: fullWidth ? overlayRect.width : null,\n          positioning: verticalPosition.positioning,\n          outsideScrollableContainer: onScrollOut != null && rectIsOutsideOfRect(activatorRect, intersectionWithViewport(scrollableContainerRect)),\n          zIndex\n        }, () => {\n          if (!this.overlay) return;\n          this.observer.observe(this.overlay, OBSERVER_CONFIG);\n          this.observer.observe(activator, OBSERVER_CONFIG);\n        });\n      });\n    };\n\n    this.observer = new MutationObserver(this.handleMeasurement);\n  }\n\n  componentDidMount() {\n    this.scrollableContainer = Scrollable.forNode(this.props.activator);\n\n    if (this.scrollableContainer && !this.props.fixed) {\n      this.scrollableContainer.addEventListener('scroll', this.handleMeasurement);\n    }\n\n    this.handleMeasurement();\n  }\n\n  componentWillUnmount() {\n    this.observer.disconnect();\n\n    if (this.scrollableContainer && !this.props.fixed) {\n      this.scrollableContainer.removeEventListener('scroll', this.handleMeasurement);\n    }\n  }\n\n  componentDidUpdate() {\n    const {\n      outsideScrollableContainer,\n      top\n    } = this.state;\n    const {\n      onScrollOut,\n      active\n    } = this.props;\n\n    if (active && onScrollOut != null && top !== 0 && outsideScrollableContainer) {\n      onScrollOut();\n    }\n  }\n\n  render() {\n    const {\n      left,\n      right,\n      top,\n      zIndex,\n      width\n    } = this.state;\n    const {\n      render,\n      fixed,\n      preventInteraction,\n      classNames: propClassNames,\n      zIndexOverride\n    } = this.props;\n    const style = {\n      top: top == null || isNaN(top) ? undefined : top,\n      left: left == null || isNaN(left) ? undefined : left,\n      right: right == null || isNaN(right) ? undefined : right,\n      width: width == null || isNaN(width) ? undefined : width,\n      zIndex: zIndexOverride || zIndex || undefined\n    };\n    const className = classNames(styles.PositionedOverlay, fixed && styles.fixed, preventInteraction && styles.preventInteraction, propClassNames);\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: className,\n      style: style,\n      ref: this.setOverlay\n    }, /*#__PURE__*/React.createElement(EventListener, {\n      event: \"resize\",\n      handler: this.handleMeasurement\n    }), render(this.overlayDetails()));\n  }\n\n  forceUpdatePosition() {\n    // Wait a single animation frame before re-measuring.\n    // Consumer's may also need to setup their own timers for\n    // triggering forceUpdatePosition() `children` use animation.\n    // Ideally, forceUpdatePosition() is fired at the end of a transition event.\n    requestAnimationFrame(this.handleMeasurement);\n  }\n\n}\n\nfunction getMarginsForNode(node) {\n  const nodeStyles = window.getComputedStyle(node);\n  return {\n    activator: parseFloat(nodeStyles.marginTop || '0'),\n    container: parseFloat(nodeStyles.marginBottom || '0'),\n    horizontal: parseFloat(nodeStyles.marginLeft || '0')\n  };\n}\n\nfunction getZIndexForLayerFromNode(node) {\n  const layerNode = node.closest(layer.selector) || document.body;\n  const zIndex = layerNode === document.body ? 'auto' : parseInt(window.getComputedStyle(layerNode).zIndex || '0', 10);\n  return zIndex === 'auto' || isNaN(zIndex) ? null : zIndex;\n}\n\nfunction isDocument(node) {\n  return node === document;\n}\n\nexport { PositionedOverlay };","map":{"version":3,"names":["React","PureComponent","classNames","getRectForNode","Rect","dataPolarisTopBar","layer","windowRect","calculateVerticalPosition","calculateHorizontalPosition","rectIsOutsideOfRect","intersectionWithViewport","styles","Scrollable","EventListener","OBSERVER_CONFIG","childList","subtree","characterData","PositionedOverlay","constructor","props","state","measuring","activatorRect","activator","right","undefined","left","top","height","width","positioning","zIndex","outsideScrollableContainer","lockPosition","overlay","scrollableContainer","observer","overlayDetails","desiredHeight","setOverlay","node","handleMeasurement","disconnect","setState","preferredPosition","preferredAlignment","onScrollOut","fullWidth","fixed","preferInputActivator","preferredActivator","querySelector","currentOverlayRect","scrollableElement","isDocument","document","body","scrollableContainerRect","overlayRect","scrollHeight","topBarOffset","topBarElement","selector","clientHeight","overlayMargins","firstElementChild","firstChild","HTMLElement","getMarginsForNode","container","horizontal","containerRect","zIndexForLayer","getZIndexForLayerFromNode","verticalPosition","horizontalPosition","Boolean","observe","MutationObserver","componentDidMount","forNode","addEventListener","componentWillUnmount","removeEventListener","componentDidUpdate","active","render","preventInteraction","propClassNames","zIndexOverride","style","isNaN","className","createElement","ref","event","handler","forceUpdatePosition","requestAnimationFrame","nodeStyles","window","getComputedStyle","parseFloat","marginTop","marginBottom","marginLeft","layerNode","closest","parseInt"],"sources":["/home/cedcoss/react/After interview/polarisdashoboard/node_modules/@shopify/polaris/build/esm/components/PositionedOverlay/PositionedOverlay.js"],"sourcesContent":["import React, { PureComponent } from 'react';\nimport { classNames } from '../../utilities/css.js';\nimport { getRectForNode, Rect } from '../../utilities/geometry.js';\nimport { dataPolarisTopBar, layer } from '../shared.js';\nimport { windowRect, calculateVerticalPosition, calculateHorizontalPosition, rectIsOutsideOfRect, intersectionWithViewport } from './utilities/math.js';\nimport styles from './PositionedOverlay.scss.js';\nimport { Scrollable } from '../Scrollable/Scrollable.js';\nimport { EventListener } from '../EventListener/EventListener.js';\n\nconst OBSERVER_CONFIG = {\n  childList: true,\n  subtree: true,\n  characterData: true\n};\nclass PositionedOverlay extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      measuring: true,\n      activatorRect: getRectForNode(this.props.activator),\n      right: undefined,\n      left: undefined,\n      top: 0,\n      height: 0,\n      width: null,\n      positioning: 'below',\n      zIndex: null,\n      outsideScrollableContainer: false,\n      lockPosition: false\n    };\n    this.overlay = null;\n    this.scrollableContainer = null;\n    this.observer = void 0;\n\n    this.overlayDetails = () => {\n      const {\n        measuring,\n        left,\n        right,\n        positioning,\n        height,\n        activatorRect\n      } = this.state;\n      return {\n        measuring,\n        left,\n        right,\n        desiredHeight: height,\n        positioning,\n        activatorRect\n      };\n    };\n\n    this.setOverlay = node => {\n      this.overlay = node;\n    };\n\n    this.handleMeasurement = () => {\n      const {\n        lockPosition,\n        top\n      } = this.state;\n      this.observer.disconnect();\n      this.setState(({\n        left,\n        top,\n        right\n      }) => ({\n        left,\n        right,\n        top,\n        height: 0,\n        positioning: 'below',\n        measuring: true\n      }), () => {\n        if (this.overlay == null || this.scrollableContainer == null) {\n          return;\n        }\n\n        const {\n          activator,\n          preferredPosition = 'below',\n          preferredAlignment = 'center',\n          onScrollOut,\n          fullWidth,\n          fixed,\n          preferInputActivator = true\n        } = this.props;\n        const preferredActivator = preferInputActivator ? activator.querySelector('input') || activator : activator;\n        const activatorRect = getRectForNode(preferredActivator);\n        const currentOverlayRect = getRectForNode(this.overlay);\n        const scrollableElement = isDocument(this.scrollableContainer) ? document.body : this.scrollableContainer;\n        const scrollableContainerRect = getRectForNode(scrollableElement);\n        const overlayRect = fullWidth ? new Rect({ ...currentOverlayRect,\n          width: activatorRect.width\n        }) : currentOverlayRect; // If `body` is 100% height, it still acts as though it were not constrained to that size. This adjusts for that.\n\n        if (scrollableElement === document.body) {\n          scrollableContainerRect.height = document.body.scrollHeight;\n        }\n\n        let topBarOffset = 0;\n        const topBarElement = scrollableElement.querySelector(`${dataPolarisTopBar.selector}`);\n\n        if (topBarElement) {\n          topBarOffset = topBarElement.clientHeight;\n        }\n\n        const overlayMargins = this.overlay.firstElementChild && this.overlay.firstChild instanceof HTMLElement ? getMarginsForNode(this.overlay.firstElementChild) : {\n          activator: 0,\n          container: 0,\n          horizontal: 0\n        };\n        const containerRect = windowRect();\n        const zIndexForLayer = getZIndexForLayerFromNode(activator);\n        const zIndex = zIndexForLayer == null ? zIndexForLayer : zIndexForLayer + 1;\n        const verticalPosition = calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed, topBarOffset);\n        const horizontalPosition = calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment);\n        this.setState({\n          measuring: false,\n          activatorRect: getRectForNode(activator),\n          left: preferredAlignment !== 'right' ? horizontalPosition : undefined,\n          right: preferredAlignment === 'right' ? horizontalPosition : undefined,\n          top: lockPosition ? top : verticalPosition.top,\n          lockPosition: Boolean(fixed),\n          height: verticalPosition.height || 0,\n          width: fullWidth ? overlayRect.width : null,\n          positioning: verticalPosition.positioning,\n          outsideScrollableContainer: onScrollOut != null && rectIsOutsideOfRect(activatorRect, intersectionWithViewport(scrollableContainerRect)),\n          zIndex\n        }, () => {\n          if (!this.overlay) return;\n          this.observer.observe(this.overlay, OBSERVER_CONFIG);\n          this.observer.observe(activator, OBSERVER_CONFIG);\n        });\n      });\n    };\n\n    this.observer = new MutationObserver(this.handleMeasurement);\n  }\n\n  componentDidMount() {\n    this.scrollableContainer = Scrollable.forNode(this.props.activator);\n\n    if (this.scrollableContainer && !this.props.fixed) {\n      this.scrollableContainer.addEventListener('scroll', this.handleMeasurement);\n    }\n\n    this.handleMeasurement();\n  }\n\n  componentWillUnmount() {\n    this.observer.disconnect();\n\n    if (this.scrollableContainer && !this.props.fixed) {\n      this.scrollableContainer.removeEventListener('scroll', this.handleMeasurement);\n    }\n  }\n\n  componentDidUpdate() {\n    const {\n      outsideScrollableContainer,\n      top\n    } = this.state;\n    const {\n      onScrollOut,\n      active\n    } = this.props;\n\n    if (active && onScrollOut != null && top !== 0 && outsideScrollableContainer) {\n      onScrollOut();\n    }\n  }\n\n  render() {\n    const {\n      left,\n      right,\n      top,\n      zIndex,\n      width\n    } = this.state;\n    const {\n      render,\n      fixed,\n      preventInteraction,\n      classNames: propClassNames,\n      zIndexOverride\n    } = this.props;\n    const style = {\n      top: top == null || isNaN(top) ? undefined : top,\n      left: left == null || isNaN(left) ? undefined : left,\n      right: right == null || isNaN(right) ? undefined : right,\n      width: width == null || isNaN(width) ? undefined : width,\n      zIndex: zIndexOverride || zIndex || undefined\n    };\n    const className = classNames(styles.PositionedOverlay, fixed && styles.fixed, preventInteraction && styles.preventInteraction, propClassNames);\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: className,\n      style: style,\n      ref: this.setOverlay\n    }, /*#__PURE__*/React.createElement(EventListener, {\n      event: \"resize\",\n      handler: this.handleMeasurement\n    }), render(this.overlayDetails()));\n  }\n\n  forceUpdatePosition() {\n    // Wait a single animation frame before re-measuring.\n    // Consumer's may also need to setup their own timers for\n    // triggering forceUpdatePosition() `children` use animation.\n    // Ideally, forceUpdatePosition() is fired at the end of a transition event.\n    requestAnimationFrame(this.handleMeasurement);\n  }\n\n}\n\nfunction getMarginsForNode(node) {\n  const nodeStyles = window.getComputedStyle(node);\n  return {\n    activator: parseFloat(nodeStyles.marginTop || '0'),\n    container: parseFloat(nodeStyles.marginBottom || '0'),\n    horizontal: parseFloat(nodeStyles.marginLeft || '0')\n  };\n}\n\nfunction getZIndexForLayerFromNode(node) {\n  const layerNode = node.closest(layer.selector) || document.body;\n  const zIndex = layerNode === document.body ? 'auto' : parseInt(window.getComputedStyle(layerNode).zIndex || '0', 10);\n  return zIndex === 'auto' || isNaN(zIndex) ? null : zIndex;\n}\n\nfunction isDocument(node) {\n  return node === document;\n}\n\nexport { PositionedOverlay };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}