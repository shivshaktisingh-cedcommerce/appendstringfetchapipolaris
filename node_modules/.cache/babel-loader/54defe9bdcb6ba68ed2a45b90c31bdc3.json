{"ast":null,"code":"import { Rect } from '../../../utilities/geometry.js';\n\nfunction calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed) {\n  let topBarOffset = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n  const activatorTop = activatorRect.top;\n  const activatorBottom = activatorTop + activatorRect.height;\n  const spaceAbove = activatorRect.top - topBarOffset;\n  const spaceBelow = containerRect.height - activatorRect.top - activatorRect.height;\n  const desiredHeight = overlayRect.height;\n  const verticalMargins = overlayMargins.activator + overlayMargins.container;\n  const minimumSpaceToScroll = overlayMargins.container;\n  const distanceToTopScroll = activatorRect.top - Math.max(scrollableContainerRect.top, 0);\n  const distanceToBottomScroll = containerRect.top + Math.min(containerRect.height, scrollableContainerRect.top + scrollableContainerRect.height) - (activatorRect.top + activatorRect.height);\n  const enoughSpaceFromTopScroll = distanceToTopScroll >= minimumSpaceToScroll;\n  const enoughSpaceFromBottomScroll = distanceToBottomScroll >= minimumSpaceToScroll;\n  const heightIfBelow = Math.min(spaceBelow, desiredHeight);\n  const heightIfAbove = Math.min(spaceAbove, desiredHeight);\n  const containerRectTop = fixed ? 0 : containerRect.top;\n  const positionIfAbove = {\n    height: heightIfAbove - verticalMargins,\n    top: activatorTop + containerRectTop - heightIfAbove,\n    positioning: 'above'\n  };\n  const positionIfBelow = {\n    height: heightIfBelow - verticalMargins,\n    top: activatorBottom + containerRectTop,\n    positioning: 'below'\n  };\n\n  if (preferredPosition === 'above') {\n    return (enoughSpaceFromTopScroll || distanceToTopScroll >= distanceToBottomScroll && !enoughSpaceFromBottomScroll) && (spaceAbove > desiredHeight || spaceAbove > spaceBelow) ? positionIfAbove : positionIfBelow;\n  }\n\n  if (preferredPosition === 'below') {\n    return (enoughSpaceFromBottomScroll || distanceToBottomScroll >= distanceToTopScroll && !enoughSpaceFromTopScroll) && (spaceBelow > desiredHeight || spaceBelow > spaceAbove) ? positionIfBelow : positionIfAbove;\n  }\n\n  if (enoughSpaceFromTopScroll && enoughSpaceFromBottomScroll) {\n    return spaceAbove > spaceBelow ? positionIfAbove : positionIfBelow;\n  }\n\n  return distanceToTopScroll > minimumSpaceToScroll ? positionIfAbove : positionIfBelow;\n}\n\nfunction calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment) {\n  const maximum = containerRect.width - overlayRect.width;\n\n  if (preferredAlignment === 'left') {\n    return Math.min(maximum, Math.max(0, activatorRect.left - overlayMargins.horizontal));\n  } else if (preferredAlignment === 'right') {\n    const activatorRight = containerRect.width - (activatorRect.left + activatorRect.width);\n    return Math.min(maximum, Math.max(0, activatorRight - overlayMargins.horizontal));\n  }\n\n  return Math.min(maximum, Math.max(0, activatorRect.center.x - overlayRect.width / 2));\n}\n\nfunction rectIsOutsideOfRect(inner, outer) {\n  const {\n    center\n  } = inner;\n  return center.y < outer.top || center.y > outer.top + outer.height;\n}\n\nfunction intersectionWithViewport(rect) {\n  let viewport = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : windowRect();\n  const top = Math.max(rect.top, 0);\n  const left = Math.max(rect.left, 0);\n  const bottom = Math.min(rect.top + rect.height, viewport.height);\n  const right = Math.min(rect.left + rect.width, viewport.width);\n  return new Rect({\n    top,\n    left,\n    height: bottom - top,\n    width: right - left\n  });\n}\n\nfunction windowRect() {\n  return new Rect({\n    top: window.scrollY,\n    left: window.scrollX,\n    height: window.innerHeight,\n    width: document.body.clientWidth\n  });\n}\n\nexport { calculateHorizontalPosition, calculateVerticalPosition, intersectionWithViewport, rectIsOutsideOfRect, windowRect };","map":{"version":3,"names":["Rect","calculateVerticalPosition","activatorRect","overlayRect","overlayMargins","scrollableContainerRect","containerRect","preferredPosition","fixed","topBarOffset","activatorTop","top","activatorBottom","height","spaceAbove","spaceBelow","desiredHeight","verticalMargins","activator","container","minimumSpaceToScroll","distanceToTopScroll","Math","max","distanceToBottomScroll","min","enoughSpaceFromTopScroll","enoughSpaceFromBottomScroll","heightIfBelow","heightIfAbove","containerRectTop","positionIfAbove","positioning","positionIfBelow","calculateHorizontalPosition","preferredAlignment","maximum","width","left","horizontal","activatorRight","center","x","rectIsOutsideOfRect","inner","outer","y","intersectionWithViewport","rect","viewport","windowRect","bottom","right","window","scrollY","scrollX","innerHeight","document","body","clientWidth"],"sources":["/home/cedcoss/react/After interview/polarisdashoboard/node_modules/@shopify/polaris/build/esm/components/PositionedOverlay/utilities/math.js"],"sourcesContent":["import { Rect } from '../../../utilities/geometry.js';\n\nfunction calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed, topBarOffset = 0) {\n  const activatorTop = activatorRect.top;\n  const activatorBottom = activatorTop + activatorRect.height;\n  const spaceAbove = activatorRect.top - topBarOffset;\n  const spaceBelow = containerRect.height - activatorRect.top - activatorRect.height;\n  const desiredHeight = overlayRect.height;\n  const verticalMargins = overlayMargins.activator + overlayMargins.container;\n  const minimumSpaceToScroll = overlayMargins.container;\n  const distanceToTopScroll = activatorRect.top - Math.max(scrollableContainerRect.top, 0);\n  const distanceToBottomScroll = containerRect.top + Math.min(containerRect.height, scrollableContainerRect.top + scrollableContainerRect.height) - (activatorRect.top + activatorRect.height);\n  const enoughSpaceFromTopScroll = distanceToTopScroll >= minimumSpaceToScroll;\n  const enoughSpaceFromBottomScroll = distanceToBottomScroll >= minimumSpaceToScroll;\n  const heightIfBelow = Math.min(spaceBelow, desiredHeight);\n  const heightIfAbove = Math.min(spaceAbove, desiredHeight);\n  const containerRectTop = fixed ? 0 : containerRect.top;\n  const positionIfAbove = {\n    height: heightIfAbove - verticalMargins,\n    top: activatorTop + containerRectTop - heightIfAbove,\n    positioning: 'above'\n  };\n  const positionIfBelow = {\n    height: heightIfBelow - verticalMargins,\n    top: activatorBottom + containerRectTop,\n    positioning: 'below'\n  };\n\n  if (preferredPosition === 'above') {\n    return (enoughSpaceFromTopScroll || distanceToTopScroll >= distanceToBottomScroll && !enoughSpaceFromBottomScroll) && (spaceAbove > desiredHeight || spaceAbove > spaceBelow) ? positionIfAbove : positionIfBelow;\n  }\n\n  if (preferredPosition === 'below') {\n    return (enoughSpaceFromBottomScroll || distanceToBottomScroll >= distanceToTopScroll && !enoughSpaceFromTopScroll) && (spaceBelow > desiredHeight || spaceBelow > spaceAbove) ? positionIfBelow : positionIfAbove;\n  }\n\n  if (enoughSpaceFromTopScroll && enoughSpaceFromBottomScroll) {\n    return spaceAbove > spaceBelow ? positionIfAbove : positionIfBelow;\n  }\n\n  return distanceToTopScroll > minimumSpaceToScroll ? positionIfAbove : positionIfBelow;\n}\nfunction calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment) {\n  const maximum = containerRect.width - overlayRect.width;\n\n  if (preferredAlignment === 'left') {\n    return Math.min(maximum, Math.max(0, activatorRect.left - overlayMargins.horizontal));\n  } else if (preferredAlignment === 'right') {\n    const activatorRight = containerRect.width - (activatorRect.left + activatorRect.width);\n    return Math.min(maximum, Math.max(0, activatorRight - overlayMargins.horizontal));\n  }\n\n  return Math.min(maximum, Math.max(0, activatorRect.center.x - overlayRect.width / 2));\n}\nfunction rectIsOutsideOfRect(inner, outer) {\n  const {\n    center\n  } = inner;\n  return center.y < outer.top || center.y > outer.top + outer.height;\n}\nfunction intersectionWithViewport(rect, viewport = windowRect()) {\n  const top = Math.max(rect.top, 0);\n  const left = Math.max(rect.left, 0);\n  const bottom = Math.min(rect.top + rect.height, viewport.height);\n  const right = Math.min(rect.left + rect.width, viewport.width);\n  return new Rect({\n    top,\n    left,\n    height: bottom - top,\n    width: right - left\n  });\n}\nfunction windowRect() {\n  return new Rect({\n    top: window.scrollY,\n    left: window.scrollX,\n    height: window.innerHeight,\n    width: document.body.clientWidth\n  });\n}\n\nexport { calculateHorizontalPosition, calculateVerticalPosition, intersectionWithViewport, rectIsOutsideOfRect, windowRect };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}