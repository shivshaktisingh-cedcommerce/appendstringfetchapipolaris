{"ast":null,"code":"// Unfortunately, this is how we have to type this at the moment.\n// There is currently a proposal to support variadic kinds.\n// https://github.com/Microsoft/TypeScript/issues/5453\nfunction merge() {\n  let final = {};\n\n  for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {\n    objs[_key] = arguments[_key];\n  }\n\n  for (const obj of objs) {\n    final = mergeRecursively(final, obj);\n  }\n\n  return final;\n}\n\nfunction mergeRecursively(inputObjA, objB) {\n  const objA = Array.isArray(inputObjA) ? [...inputObjA] : { ...inputObjA\n  };\n\n  for (const key in objB) {\n    if (!Object.prototype.hasOwnProperty.call(objB, key)) {\n      continue;\n    } else if (isMergeableValue(objB[key]) && isMergeableValue(objA[key])) {\n      objA[key] = mergeRecursively(objA[key], objB[key]);\n    } else {\n      objA[key] = objB[key];\n    }\n  }\n\n  return objA;\n}\n\nfunction isMergeableValue(value) {\n  return value !== null && typeof value === 'object';\n}\n\nexport { merge };","map":{"version":3,"names":["merge","final","objs","obj","mergeRecursively","inputObjA","objB","objA","Array","isArray","key","Object","prototype","hasOwnProperty","call","isMergeableValue","value"],"sources":["/home/cedcoss/react/After interview/polarisdashoboard/node_modules/@shopify/polaris/build/esm/utilities/merge.js"],"sourcesContent":["// Unfortunately, this is how we have to type this at the moment.\n// There is currently a proposal to support variadic kinds.\n// https://github.com/Microsoft/TypeScript/issues/5453\nfunction merge(...objs) {\n  let final = {};\n\n  for (const obj of objs) {\n    final = mergeRecursively(final, obj);\n  }\n\n  return final;\n}\n\nfunction mergeRecursively(inputObjA, objB) {\n  const objA = Array.isArray(inputObjA) ? [...inputObjA] : { ...inputObjA\n  };\n\n  for (const key in objB) {\n    if (!Object.prototype.hasOwnProperty.call(objB, key)) {\n      continue;\n    } else if (isMergeableValue(objB[key]) && isMergeableValue(objA[key])) {\n      objA[key] = mergeRecursively(objA[key], objB[key]);\n    } else {\n      objA[key] = objB[key];\n    }\n  }\n\n  return objA;\n}\n\nfunction isMergeableValue(value) {\n  return value !== null && typeof value === 'object';\n}\n\nexport { merge };\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,KAAT,GAAwB;EACtB,IAAIC,KAAK,GAAG,EAAZ;;EADsB,kCAANC,IAAM;IAANA,IAAM;EAAA;;EAGtB,KAAK,MAAMC,GAAX,IAAkBD,IAAlB,EAAwB;IACtBD,KAAK,GAAGG,gBAAgB,CAACH,KAAD,EAAQE,GAAR,CAAxB;EACD;;EAED,OAAOF,KAAP;AACD;;AAED,SAASG,gBAAT,CAA0BC,SAA1B,EAAqCC,IAArC,EAA2C;EACzC,MAAMC,IAAI,GAAGC,KAAK,CAACC,OAAN,CAAcJ,SAAd,IAA2B,CAAC,GAAGA,SAAJ,CAA3B,GAA4C,EAAE,GAAGA;EAAL,CAAzD;;EAGA,KAAK,MAAMK,GAAX,IAAkBJ,IAAlB,EAAwB;IACtB,IAAI,CAACK,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCR,IAArC,EAA2CI,GAA3C,CAAL,EAAsD;MACpD;IACD,CAFD,MAEO,IAAIK,gBAAgB,CAACT,IAAI,CAACI,GAAD,CAAL,CAAhB,IAA+BK,gBAAgB,CAACR,IAAI,CAACG,GAAD,CAAL,CAAnD,EAAgE;MACrEH,IAAI,CAACG,GAAD,CAAJ,GAAYN,gBAAgB,CAACG,IAAI,CAACG,GAAD,CAAL,EAAYJ,IAAI,CAACI,GAAD,CAAhB,CAA5B;IACD,CAFM,MAEA;MACLH,IAAI,CAACG,GAAD,CAAJ,GAAYJ,IAAI,CAACI,GAAD,CAAhB;IACD;EACF;;EAED,OAAOH,IAAP;AACD;;AAED,SAASQ,gBAAT,CAA0BC,KAA1B,EAAiC;EAC/B,OAAOA,KAAK,KAAK,IAAV,IAAkB,OAAOA,KAAP,KAAiB,QAA1C;AACD;;AAED,SAAShB,KAAT"},"metadata":{},"sourceType":"module"}